---
title: "Surface Geometry"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Surface Geometry}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 6,
  fig.height = 4
)
```

The cortical surface is not flat. Two regions can be close in Euclidean
space---a straight line through the brain---yet far apart along the cortical
sheet. This distinction matters whenever distance drives an analysis: computing
spatial autocorrelation, selecting neighbours, or estimating how much cortex a
region actually covers.
neuromapr provides tools for working with triangular surface meshes: building
graphs, computing geodesic distances, and calculating per-vertex surface areas.

```{r setup}
library(neuromapr)
```

## Surface meshes

A cortical surface mesh consists of two pieces:

- **Vertices**: an n x 3 matrix of 3D coordinates, one row per point on the surface.
- **Faces**: an m x 3 matrix of integer indices, each row defining a triangle by
  referencing three vertices.

Together they describe the geometry. We will build a small mesh by hand to
make the examples concrete:

```{r mesh}
vertices <- matrix(c(
  0, 0, 0,
  1, 0, 0,
  0.5, 1, 0,
  1.5, 1, 0,
  0, 2, 0,
  1, 2, 0
), ncol = 3, byrow = TRUE)

faces <- matrix(c(
  1, 2, 3,
  2, 3, 4,
  3, 4, 6,
  3, 5, 6
), ncol = 3, byrow = TRUE)
```

This gives us six vertices and four triangles forming a small irregular strip.
Real cortical surfaces have tens of thousands of vertices, but the operations
are the same.

## Building a surface graph

`make_surf_graph()` takes a mesh and returns a weighted graph. Each edge
connects two vertices that share a triangle, and the weight is the Euclidean
distance between them.

```{r graph, eval = TRUE}
g <- make_surf_graph(vertices, faces)
g
```

The graph is the foundation for geodesic distance computation. It captures the
connectivity structure of the mesh---which vertices are adjacent, and how far
apart they are along the surface.

## Geodesic distances

Euclidean distance is a straight line through 3D space. Geodesic distance follows
the surface, taking the shortest path along mesh edges. For a convoluted surface
like the cortex, the two can differ substantially.

`get_surface_distance()` computes geodesic distances via Dijkstra's algorithm on
the surface graph:

```{r geodesic-full, eval = TRUE}
dmat <- get_surface_distance(vertices, faces)
dmat
```

The result is a symmetric n x n matrix of shortest-path distances.

### Partial distance matrices

Computing the full n x n matrix is expensive for large meshes. If you only need
distances from a subset of source vertices, pass them explicitly:

```{r geodesic-partial, eval = TRUE}
dmat_partial <- get_surface_distance(vertices, faces, source_vertices = c(1, 6))
dmat_partial
```

This returns a 2 x 6 matrix: distances from vertices 1 and 6 to all six
vertices. For parcellation centroid computations and neighbourhood queries, this
selective approach saves considerable time.

### Euclidean vs geodesic

The `compute_distance_matrix()` utility supports both methods:

```{r compare-distances, eval = TRUE}
euclid <- compute_distance_matrix(vertices, method = "euclidean")
geodesic <- compute_distance_matrix(vertices, method = "geodesic", faces = faces)

max(abs(geodesic - euclid))
```

On a flat mesh the two are identical. On a folded cortex, geodesic distances
are always greater than or equal to Euclidean distances, often substantially so
for regions separated by a sulcus.

## Vertex areas

Each vertex on a surface mesh represents a patch of cortex. Knowing its area
matters for area-weighted averaging and for understanding how much cortical
surface a parcel actually covers.

`vertex_areas()` assigns area by distributing each triangle's area equally among
its three vertices:

```{r vertex-areas}
areas <- vertex_areas(vertices, faces)
areas
```

```{r total-area}
sum(areas)
```

The total vertex area equals the total surface area of all triangles. The
per-vertex values tell you how much surface each vertex represents. Corner
vertices (part of fewer triangles) get less area than interior vertices (shared
by many triangles).

### Checking the geometry

A useful sanity check: compute the triangle areas directly and verify they match.

```{r triangle-check}
tri_area <- function(v, f) {
  a <- v[f[1], ]
  b <- v[f[2], ]
  c <- v[f[3], ]
  ab <- b - a
  ac <- c - a
  cross <- c(
    ab[2] * ac[3] - ab[3] * ac[2],
    ab[3] * ac[1] - ab[1] * ac[3],
    ab[1] * ac[2] - ab[2] * ac[1]
  )
  0.5 * sqrt(sum(cross^2))
}

total_tri <- sum(vapply(seq_len(nrow(faces)), function(i) {
  tri_area(vertices, faces[i, ])
}, numeric(1)))

all.equal(sum(areas), total_tri)
```

## Format conversions

Cortical surfaces come in many file formats. FreeSurfer uses its own binary
formats (`.annot` for parcellations, `.curv`/`.thickness`/`.sulc` for
morphometry), while modern tools increasingly expect GIFTI. neuromapr provides
two conversion functions.

### Annotation to GIFTI

`annot_to_gifti()` converts a FreeSurfer `.annot` file (parcellation labels) to
a GIFTI label file:

```r
annot_to_gifti("lh.aparc.annot", "lh.aparc.label.gii")
```

### Morphometry to GIFTI

`fsmorph_to_gifti()` converts FreeSurfer morphometry files to GIFTI func files:

```r
fsmorph_to_gifti("lh.thickness", "lh.thickness.func.gii")
```

Both functions require the **freesurferformats** and **gifti** packages. If no
output path is given, they replace the file extension automatically (`.annot`
becomes `.label.gii`, `.curv` becomes `.func.gii`).

## Putting it together

A typical workflow that combines surface geometry with the rest of neuromapr:

1. **Load a surface mesh** (from a GIFTI `.surf.gii` file).
2. **Compute geodesic distances** between parcel centroids.
3. **Use that distance matrix** for spatially-constrained null model generation.

```r
centroids <- get_parcel_centroids(vertices, labels, method = "surface")
distmat <- as.matrix(dist(centroids))
nulls <- generate_nulls(parcel_data, method = "burt2020", distmat = distmat)
```

For analyses where the distinction between Euclidean and geodesic distance
matters---highly folded cortex, parcels separated by deep sulci---computing
geodesic distances between centroids can produce more accurate null models.

## References

Markello RD, Hansen JY, Liu Z-Q, et al. (2022). neuromaps: structural and
functional interpretation of brain maps. *Nature Methods*, 19, 1472--1480.
doi:10.1038/s41592-022-01625-w
